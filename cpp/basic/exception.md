## 程序进行栈解退以回到能够捕获异常的地方时，将释放栈中的自动存储型变量，如果变量是类对象，将为该对象调用析构函数

## 使用省略号表示异常类型，表示能够捕获任何异常

## C++异常的最佳实践
以值的形式抛出、以引用的形式捕获
C++中针对异常的最佳实践中有一条：throw by value catch by reference，即以值的形式抛出、以引用的形式捕获。

以值的形式抛出异常对象后，栈展开不会销毁该异常对象吗？此时如何引用到该异常对象？
我们知道，寻找合适的异常处理块过程中，会进行栈展开（stack unwinding），即如果这层函数调用中，没有合适的异常处理快，会销毁这层函数调用的栈帧，回溯到上一层函数调用，在上一层函数调用中寻找合适的异常处理块，问题是销毁本层函数的栈帧，会销毁栈上分配的变量，而我们的异常对象如果是以值的形式构建的，那么该异常对象就是栈上分配的，此时栈展开就会销毁该异常对象，那么如果合适的异常处理块在上一层，该异常处理块如何以引用的形式引用到该被销毁的异常对象呢？

答案是：编译器会生成代码帮忙把在栈展开过程中，把抛出的异常对象，拷贝到上一层栈帧中， 这意味着，如果以值的形式抛出一个异常对象，我们的异常对象需要是能被拷贝的，即需要有拷贝构造函数。 不过由于异常一般都是以临时对象形式抛出的，所以一般调用的不是拷贝构造函数，而是移动构造函数。

### 为什么要以值的形式抛出？
为什么要以值的形式抛出，为什么不new一个异常对象，抛出该异常对象，这样做会有什么问题吗？
new一个对象，我们就得考虑如何保证该对象被释放，首先，该对象在被捕获之前以及在被捕获后异常处理块的代码执行过程中，都是不能被释放的。那异常处理块执行完后呢？谁去负责释放？似乎只有两个候选人了，即捕获该异常的异常处理块或者让编译器在异常处理块中自动插入释放异常的代码，前者由于每个异常处理块都得写释放逻辑，代码重复量大，易漏写，只有后者可行点。
即使编译器可以帮插代码去释放，还得考虑一个问题：如果在new一个异常对象的过程中，new抛出异常，那该新异常会替代原始异常，寻找对应的异常处理块以及在必要时进行栈展开，这个过程是不可恢复的，故老异常直接丢失，此时我们就没办法知道原本发生异常的原因了，这会导致异常处理不可靠。

### 为什么要以引用形式捕获异常对象？
理由应该是比较简单的：减少一次不必要的拷贝。
除此之外，标准还说，异常对象会被视为左值，故即使它是临时对象，也可以绑定在非const引用上。

### 异常类的拷贝/移动构造函数不能抛出异常
前面我们在 为什么要以值的形式抛出？ 中也说过抛出异常会导致的问题了。这里原因是差不多的，如果允许异常类的拷贝构造函数抛出异常，那新抛出的异常会替代原始异常，寻找对应的异常处理块以及在必要时进行栈展开，这个过程是不可恢复的，老异常直接丢失，此时我们就没办法知道原本发生异常的原因了，这会导致异常处理不可靠，于是标准要求异常类的拷贝构造函数不能抛出异常（同理，如果抛出的是临时异常对象，导致用的是移动构造函数，那移动构造函数也不能抛出异常），更进一步的，标准要求：如果在异常类的拷贝构造函数中抛出异常，会直接调用std::terminate结束程序。

综上，我们应该要保证异常类的拷贝/移动构造函数不抛出异常，并加上 noexcept修饰符，同理，为了不要掩盖发生异常的真实原因（见：为什么要以值的形式抛出？），构造函数也应该不要抛出异常，也应该加上noexcept修饰符。

由于常用的std::string类的拷贝构造函数是可能会抛出异常的，故在异常类中不应该内嵌std::string类，这点在boost的错误处理文档中也有提及，具体见： Error and Exception Handling。

我们可以写代码来验证栈展开过程中，异常对象会被拷贝/移动，如下：
```cpp
#include <exception>
#include <iostream>

class MyException : public std::exception {
 public:
  explicit MyException(const char *msg) noexcept : msg_(msg) {
    std::cout << "Construct MyException" << std::endl;
  }

  MyException(const MyException &rhs) noexcept : msg_(rhs.msg_) {
    std::cout << "Copy MyException" << std::endl;
  }

  const char *what() const noexcept override {
    return msg_;
  }

 private:
  const char *msg_;
};

void C() {
  throw MyException("A message");
}

void B() {
  C();
}

void A() {
  B();
}

int main() {
  try {
    A();
  } catch (const MyException &e) {
    std::cout << "Catch MyException: " << e.what() << std::endl;
  }
}
```
运行上面代码，输出如下：
Construct MyException
Catch MyException: A message
异常对象并没有被拷贝，这是由于Copy elision造成的，具体参考Copy elision。

这里为了禁止Copy elision，可以传编译器选项去禁用，比如 GCC/G++的-fno-elide-constructors，或者我们直接加个变量去引用这个异常对象，从而不满足Copy elision的使用条件，把函数C的代码改成如下：
```cpp
void C() {
  MyException e("A message");
  throw e;
}
```
此时运行如下：
Construct MyException
Copy MyException
Catch MyException: A message

可以看到，虽然main到C之间有三次栈展开（C的、B的、A的），但是只有一次拷贝，换句话来说，并不是每次栈展开都拷贝，而是不管多少层调用，都只拷贝一次，要做到这个不难，编译器一般会在运行时维护一条异常处理器链表，按作用域顺序排列，最近作用域的异常处理器会在链表的最前端，当前作用域结束时，对应的链表最前端的异常处理器也会被移除，从而还原上一层作用域的异常处理器链表状态，以此来维持异常处理器链表和作用域的一致性，因此编译器只要在栈展开前，按顺序搜索异常处理器链表，即按作用域顺序搜索异常处理器链表，提前找到匹配的异常处理器，顺带计算下要展开几层的栈（可以在异常处理器结构体中附加编译器自己的一些额外信息以辅助计算，比如并不是每层作用域都对应一次函数调用，有的只是函数内的嵌套作用域而已），定位对应的栈帧，先执行拷贝，拷贝完后，再开始栈展开。

