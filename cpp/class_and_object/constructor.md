## 默认构造函数
隐式的调用默认构造函数时，不要使用圆括号
```cpp
Stock first = Stock(); //call default constructor
Stock second(); //declares a function
Stock third; //call default constructor
```

### 有用的
默认的构造函数分为有用的和无用的，所谓无用的默认构造函数就是一个空函数、什么操作也不做，而有用的默认构造函数是可以初始化成员的函数。
对构造函数的需求也是分为两类：一类是编辑器需求，一类是程序的需求。
	程序的需求：若程序需求构造函数时，就是要程序员自定义构造函数来显示的初始化类的数据成员。
	编辑器的需求：编辑器的需求也分为两类：一类是无用的空的构造函数(trivial)，一类是编辑器自己合成的有用的构造函数(non-trivival)。


在用户没有自定义构造函数的情况下：
一、由于编辑器的需求，编辑器会生成空的无用的默认构造函数。
二、但在某些情况下,编辑器就一定会合有用的默认构造函数。





## 初始化列表
构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。例如：
```cpp
class CExample {
public:
    int a;
    float b;
    //构造函数初始化列表
    CExample(): a(0),b(8.8)
    {}
    //构造函数内部赋值
    CExample()
    {
        a=0;
        b=8.8;
    }
};
```

#### 初始化列表的成员初始化顺序:
C++ 初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。
```cpp
class CMyClass {
    CMyClass(int x, int y);
    int m_x;
    int m_y;
};

CMyClass::CMyClass(int x, int y) : m_y(y), m_x(m_y)
{
};
```
你可能以为上面的代码将会首先做 m_y=y，然后做 m_x=m_y，最后它们有相同的值。但是编译器先初始化 m_x，然后是 m_y,因为它们是按这样的顺序声明的。结果是 m_x 将有一个不可预测的值。

## 赋值
```cpp
Stock stock1("NanoSmart", 12, 20.0);            
//stock1 对象已经存在，所以这里是将新值赋给它，这是通过创建一个新的、临时的对象，然后将其内容复制给stock1实现的
//随后程序调用析构函数，以删除该临时象
stock1 = Stock("Nifty Foods", 10, 50.0);    
```
