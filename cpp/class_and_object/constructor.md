## 默认构造函数
隐式的调用默认构造函数时，不要使用圆括号
```cpp
Stock first = Stock(); //call default constructor
Stock second(); //declares a function
Stock third; //call default constructor
```

### 有用的
默认的构造函数分为有用的和无用的，所谓无用的默认构造函数就是一个空函数、什么操作也不做，而有用的默认构造函数是可以初始化成员的函数。
对构造函数的需求也是分为两类：一类是编辑器需求，一类是程序的需求。
	程序的需求：若程序需求构造函数时，就是要程序员自定义构造函数来显示的初始化类的数据成员。
	编辑器的需求：编辑器的需求也分为两类：一类是无用的空的构造函数(trivial)，一类是编辑器自己合成的有用的构造函数(non-trivival)。


在用户没有自定义构造函数的情况下：
一、由于编辑器的需求，编辑器会生成空的无用的默认构造函数。
二、但在某些情况下,编辑器就一定会合有用的默认构造函数。


## c11 允许类成员在定义的时候即进行初始化


## 初始化列表
构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。例如：
```cpp
class CExample {
public:
    int a;
    float b;
    //构造函数初始化列表
    CExample(): a(0),b(8.8)
    {}
    //构造函数内部赋值
    CExample()
    {
        a=0;
        b=8.8;
    }
};
```
#### 常量和被声明为引用的类成员必须使用初始化列表初始化。

#### 初始化列表的成员初始化顺序:
C++ 初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。
```cpp
class CMyClass {
    CMyClass(int x, int y);
    int m_x;
    int m_y;
};

CMyClass::CMyClass(int x, int y) : m_y(y), m_x(m_y)
{
};
```
你可能以为上面的代码将会首先做 m_y=y，然后做 m_x=m_y，最后它们有相同的值。但是编译器先初始化 m_x，然后是 m_y,因为它们是按这样的顺序声明的。结果是 m_x 将有一个不可预测的值。

## 赋值
```cpp
Stock stock1("NanoSmart", 12, 20.0);            
//stock1 对象已经存在，所以这里是将新值赋给它，这是通过创建一个新的、临时的对象，然后将其内容复制给stock1实现的
//随后程序调用析构函数，以删除该临时象
stock1 = Stock("Nifty Foods", 10, 50.0);    
```


## 复制构造函数
```cpp
Class_name(const Class_name &)
```
### 何时调用复制构造函数
```cpp
Complex c2(c1);
Complex c2 = c1;
Complex c2 = Complex(c1);
Complex *c2 = new Complex(c1);
```
中间的两种可能会使用复制构造函数直接创建c2，或者使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给c2，这取决于具体的实现。最后一种使用c1初始化一个匿名对象，并将新对象的地址赋给A指针。

每当程序生成了对象副本时，编译器都将使用复制构造函数。具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。记住，按值传递意味着创建原始变量的一个副本。编译器生成临时对象时，也将使用复制构造函数。
何时生成临时对象随编译器而异，但无论是哪种编译器，当按值传递和返回对象时，都将调用复制构造函数。


### 何时需要复制构造函数
通常，如果一个类中包含指向动态分配存储空间的指针类型的成员变量时，就应该为这个类设计一个拷贝构造函数，这被称为深赋值.
除了需要设计一个拷贝构造函数之外，还需要为它添加一个赋值操作符重载函数（即重载“=”操作符）。

## 赋值运算符
C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的。这种运算符 的原型如下：
```cpp
Class_name & Class_name::operator=(const Class_name &);
```
与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制，静态成员不受影响。

### 何时调用
将已有的对象赋给另一个对象时，将使用重载的赋值运算符。初始化对象时，并不一定会使用赋值运算符，而更可能是调用复制构造函数。
```cpp
ca = knot; //调用了赋值运算符 
StringBad metoo = knot;  //调用了拷贝构造函数，也可能会调用赋值运算符
```
这里，metoo 是一个新创建的对象，被初始化为 knot 的值，因此使用复制构造函数。
然而，正如前面指出的，实现时也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时对象的值复制到新对象中。
这就是说，初始化总是会调用复制构造函数，而使用 = 运算符时也可能调用赋值运算符。

### 示例
```cpp
// assign a String to a String
String & String::operator=(const String & st) //返回一个指向调用对象的引用
{
    if (this == &st)
        return *this; //函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容；
        
    delete [] str; //需要先释放之前申请的内存
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    return *this;
}
```
