### MOV 指令
MOV 指令用于将数据从一个寄存器拷贝到另外一个寄存器，或者将一个立即数传递到寄存器里面
```cpp
MOV R0，R1 	//将寄存器 R1 中的数据传递给 R0，即 R0=R1 
MOV R0, #0X12 //将立即数 0X12 传递给 R0 寄存器，即 R0=0X12
```

### LDR 指令
LDR 主要用于从内存中加载数据到寄存器中，LDR 也可以将一个立即数加载到寄存器Rx中，LDR 加载立即数的时候要使用“=”，而不是“#”。
```asm
ldr x0, [x1]          ; 将寄存器 x1 的值作为地址，取该内存地址的值放入寄存器 x0 中 
ldr w8, [sp, #0x8]    ; 将栈内存 [sp + 0x8] 处的值读取到 w8 寄存器中 
ldr x0, [x1, #4]!     ; 将寄存器 x1 的值加上 4 作为内存地址, 取该内存地址的值放入寄存器 x0 中, 然后将寄存器 x1 的值加上 4 放入寄存器 x1 中 
ldr x0, [x1], #4      ; 将寄存器 x1 的值作为内存地址，取内该存地址的值放入寄存器 x0 中, 再将寄存器 x1 的值加上 4 放入寄存器 x1 中 
ldr x0, [x1, x2]      ; 将寄存器 x1 和寄存器 x2 的值相加作为地址，取该内存地址的值放入寄存器 x0 中
```

## STR 指令(store register)
将数据从寄存器中读出来, 写入到内存中
```cpp
str w9, [sp, #0x8]    ; 将寄存器 w9 中的值保存到栈内存 [sp + 0x8] 处 
```

 
## PUSH
```asm
PUSH {r3，lr}  //将寄存器r3和lr写入内存栈 
PUSH {R0~R3, R12} //将 R0~R3 和 R12 压栈
```
本质是写内存STR指令，高标号寄存器写入高地址的栈里，低标号寄存器写入低地址的栈里
lr即r14，写入地址为sp-4的内存，然后：sp=sp-4
r3，写入地址为sp-4的内存，然后：sp=sp-4

## POP
```asm
POP {r3，pc}  //取出内存栈的数据放入r3和pc中 
```
本质是读内存LDR指令，高标号寄存器的内容来自高地址的栈，低标号寄存器的内容来自低地址的栈
读地址为sp的内存存入r3，然后：sp=sp+4
读地址为sp的内存存入pc，然后：sp=sp+4


## ADD/SUB
```cpp
ADD r0,r1,r2  意思为：r0=r1+r2
SUB r0,r1,r2  意思为：r0=r1-r2
```

## B 指令
这是最简单的跳转指令，B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指令，ARM 处理器就会立即跳转到指定的目标地址。如果要调用的函数不会再返回到原来的执行处，那就可以用 B 指令

```cpp
b main //跳转到 main 函数
```


## BL 指令
BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行，这是子程序调用一个常用的手段。


## 寄存器
R14 LR 保存返回地址
