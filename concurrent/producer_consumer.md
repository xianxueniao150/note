# 生产者消费者

## 什么是生产者/消费者模型
生产者/消费者模型描述的是有一块缓冲区作为仓库，生产者可将产品放入仓库，消费者可以从仓库中取出产品

## 个人总结
假设缓冲区是一块无限长的数组。生产者需要记录生产到哪的坐标，消费者需要记录消费到哪的坐标。
假如有多个生产者的话，在向数组中放入产品的时候就需要加锁。消费者同理。但生产者消费者可以各用各的锁。消费者在消费之前需要判断是否有能够消费的产品。
如果消费者总是轮询去检查的话，可能会造成cpu浪费。此时就可以通过条件变量——消费者等待，生产者生产完后就去通知消费者。
同理，如果缓存区会满的话，生产者也需要轮询检查或者让消费者通知它。

## 小心假死
生产者/消费者模型最终达到的目的是平衡生产者和消费者的处理能力，达到这个目的的过程中，并不要求只有一个生产者和一个消费者。可以多个生产者对应多个消费者，可以一个生产者对应一个消费者，可以多个生产者对应一个消费者。
假死就发生在上面三种场景下。假死指的是全部线程都进入了WAITING状态，那么程序就不再执行任何业务功能了，整个项目呈现停滞状态。
比方说有生产者A和生产者B，缓冲区由于空了，消费者处于WAITING。生产者B处于WAITING，生产者A被消费者通知生产，生产者A生产出来的产品本应该通知消费者，结果通知了生产者B，生产者B被唤醒，发现缓冲区满了，于是继续WAITING。至此，两个生产者线程处于WAITING，消费者处于WAITING，系统假死。
上面的分析可以看出，假死出现的原因是因为notify的是同类，所以非单生产者/单消费者的场景，可以采取两种方法解决这个问题：
1、用notifyAll()唤醒所有线程
2、定义两个Condition，一个表示生产者的Condition，一个表示消费者的Condition，唤醒的时候调用相应的Condition的signal()方法就可以了

