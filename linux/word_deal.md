# sed
stream editor（流编辑器）
sed 的工作方式是要不给出单个编辑命令（在命令行中）要不就是包含多个命令的脚本文件名， 然后它就按行来执行这些命令。这里有一个非常简单的 sed 实例：
```
[me@linuxbox ~]$ echo "front" | sed 's/front/back/'
back
```
sed，依次， 对流文本执行指令 s/front/back/，随后输出“back”。我们也能够把这个命令认为是相似于 vi 中的“替换” （查找和替代）命令。

sed 中的命令开始于单个字符。在上面的例子中，这个替换命令由字母 s 来代表，斜杠字符做为分隔符。分隔符的选择是随意的。按照惯例，经常使用斜杠字符， 但是 sed 将会接受紧随命令之后的任意字符做为分隔符。我们可以按照这种方式来执行相同的命令：
```
[me@linuxbox ~]$ echo "front" | sed 's\_front\_back\_'
back
```
通过紧跟命令之后使用下划线字符，则它变成界定符。sed 可以设置界定符的能力，使命令的可读性更强， 正如我们将看到的.

### sed 地址表示法
sed 中的大多数命令之前都会带有一个地址，其指定了输入流中要被编辑的文本行。如果省略了地址， 然后会对输入流的每一行执行编辑命令。最简单的地址形式是一个行号。我们能够添加一个地址 到我们例子中：
```
[me@linuxbox ~]$ echo "front" | sed '1s/front/back/'
back
```
给我们的命令添加地址 1，就导致只对仅有一行文本的输入流的第一行执行替换操作。

表21-7: sed 地址表示法
| 地址        | 说明                                                                                                                                                                                 |
|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| n           | 行号，n 是一个正整数。                                                                                                                                                               |
| $           | 最后一行。                                                                                                                                                                           |
| /regexp/    | 所有匹配一个 POSIX 基本正则表达式的文本行。注意正则表达式通过 斜杠字符界定。选择性地，这个正则表达式可能由一个备用字符界定，通过\cregexpc 来 指定表达式，这里 c 就是一个备用的字符。 |
| addr1,addr2 | 从 addr1 到 addr2 范围内的文本行，包含地址 addr2 在内。地址可能是上述任意 单独的地址形式。                                                                                           |
| first~step  | 匹配由数字 first 代表的文本行，然后随后的每个在 step 间隔处的文本行。例如 1~2 是指每个位于偶数行号的文本行，5~5 则指第五行和之后每五行位置的文本行。                                 |
| addr1,+n    | 匹配地址 addr1 和随后的 n 个文本行。                                                                                                                                                 |
| addr!       | 匹配所有的文本行，除了 addr 之外，addr 可能是上述任意的地址形式。                                                                                                                    |

通过使用这一章中早前的 distros.txt 文件，我们将演示不同种类的地址表示法。首先，一系列行号：

[me@linuxbox ~]$ sed -n '1,5p' distros.txt
SUSE           10.2     12/07/2006
Fedora         10       11/25/2008
SUSE           11.0     06/19/2008
Ubuntu         8.04     04/24/2008
Fedora         8        11/08/2007
在这个例子中，我们打印出一系列的文本行，开始于第一行，直到第五行。为此，我们使用 p 命令， 其就是简单地把匹配的文本行打印出来。然而为了高效，我们必须包含选项 -n（不自动打印选项）， 让 sed 不要默认地打印每一行。

下一步，我们将试用一下正则表达式：

[me@linuxbox ~]$ sed -n '/SUSE/p' distros.txt
SUSE         10.2     12/07/2006
SUSE         11.0     06/19/2008
SUSE         10.3     10/04/2007
SUSE         10.1     05/11/2006
通过包含由斜杠界定的正则表达式 \/SUSE\/，我们能够孤立出包含它的文本行，和 grep 程序的功能 是相同的。

最后，我们将试着否定上面的操作，通过给这个地址添加一个感叹号：

[me@linuxbox ~]$ sed -n '/SUSE/!p' distros.txt
Fedora         10       11/25/2008
Ubuntu         8.04     04/24/2008
Fedora         8        11/08/2007
Ubuntu         6.10     10/26/2006
Fedora         7        05/31/2007
Ubuntu         7.10     10/18/2007
Ubuntu         7.04     04/19/2007
Fedora         6        10/24/2006
Fedora         9        05/13/2008
Ubuntu         6.06     06/01/2006
Ubuntu         8.10     10/30/2008
Fedora         5        03/20/2006
这里我们看到期望的结果：输出了文件中所有的文本行，除了那些匹配这个正则表达式的文本行。

目前为止，我们已经知道了两个 sed 的编辑命令，s 和 p。这里是一个更加全面的基本编辑命令列表：

表21-8: sed 基本编辑命令
| 命令 | 说明                                                                                                                             |
|------|----------------------------------------------------------------------------------------------------------------------------------|
| = | 输出当前的行号。                                                                                                                 |
| a | 在当前行之后追加文本。                                                                                                           |
| d | 删除当前行。                                                                                                                     |
| i | 在当前行之前插入文本。                                                                                                           |
| p | 打印当前行。默认情况下，sed 程序打印每一行，并且只是编辑文件中匹配 指定地址的文本行。通过指定-n 选项，这个默认的行为能够被忽略。 |
| q | 退出 sed，不再处理更多的文本行。如果不指定-n 选项，输出当前行。                                                                  |
| Q | 退出 sed，不再处理更多的文本行。                                                                                                 |



s/regexp/replacement/	只要找到一个 regexp 匹配项，就替换为 replacement 的内容。 replacement 可能包括特殊字符 &，其等价于由 regexp 匹配的文本。另外， replacement 可能包含序列 \1到 \9，其是 regexp 中相对应的子表达式的内容。更多信息，查看 下面 back references 部分的讨论。在 replacement 末尾的斜杠之后，可以指定一个 可选的标志，来修改 s 命令的行为。
y/set1/set2	执行字符转写操作，通过把 set1 中的字符转变为相对应的 set2 中的字符。 注意不同于 tr 程序，sed 要求两个字符集合具有相同的长度。
到目前为止，这个 s 命令是最常使用的编辑命令。我们将仅仅演示一些它的功能，通过编辑我们的 distros.txt 文件。我们以前讨论过 distros.txt 文件中的日期字段不是“友好地计算机”模式。 文件中的日期格式是 MM/DD/YYYY，但如果格式是 YYYY-MM-DD 会更好一些（利于排序）。手动修改 日期格式不仅浪费时间而且易出错，但是有了 sed，只需一步就能完成修改：

```
[me@linuxbox ~]$ sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt
SUSE           10.2     2006-12-07
Fedora         10       2008-11-25
```
哇！这个命令看起来很丑陋。但是它起作用了。仅用一步，我们就更改了文件中的日期格式。 让我们看一下 怎样来构建它。首先，我们知道此命令有这样一个基本的结构：
```
sed 's/regexp/replacement/' distros.txt
```
我们下一步是要弄明白一个正则表达式将要孤立出日期。因为日期是 MM/DD/YYYY 格式，并且 出现在文本行的末尾，我们可以使用这样的表达式：
```
[0-9]{2}/[0-9]{2}/[0-9]{4}$
```
此表达式匹配两位数字，一个斜杠，两位数字，一个斜杠，四位数字，以及行尾。如此关心regexp， 那么_replacement_又怎样呢？为了解决此问题，我们必须介绍一个正则表达式的新功能，它出现 在一些使用 BRE 的应用程序中。这个功能叫做逆参照，像这样工作：如果序列\n 出现在_replacement_中 ，这里 n 是指从 1 到 9 的数字，则这个序列指的是在前面正则表达式中相对应的子表达式。为了 创建这个子表达式，我们简单地把它们用圆括号括起来，像这样：
```
([0-9]{2})/([0-9]{2})/([0-9]{4})$
```
现在我们有了三个子表达式。第一个表达式包含月份，第二个包含某月中的某天，以及第三个包含年份。 现在我们就可以构建replacement，如下所示：
```
\3-\1-\2
```
此表达式给出了年份，一个斜杠，月份，一个斜杠，和某天。
```
sed 's/([0-9]{2})/([0-9]{2})/([0-9]{4})$/\3-\1-\2/' distros.txt
```
我们还有两个问题。第一个是在我们表达式中额外的斜杠将会迷惑 sed。第二个是因为 sed，默认情况下，只接受基本的正则表达式，在表达式中的几个字符会 被当作文字字面值，而不是元字符。我们能够解决这两个问题，通过反斜杠的自由应用来转义 令人不快的字符：
```
sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt
```
你掌握了吧!

s 命令的另一个功能是使用可选标志，其跟随替代字符串。一个最重要的可选标志是 g 标志，其 指示 sed 对某个文本行全范围地执行查找和替代操作，不仅仅是对第一个实例，这是默认行为。 这里有个例子：

[me@linuxbox ~]$ echo "aaabbbccc" | sed 's/b/B/'
aaaBbbccc
我们看到虽然执行了替换操作，但是只针对第一个字母 “b” 实例，然而剩余的实例没有更改。通过添加 g 标志， 我们能够更改所有的实例：

[me@linuxbox ~]$ echo "aaabbbccc" | sed 's/b/B/g'
aaaBBBccc
目前为止，通过命令行我们只让 sed 执行单个命令。使用-f 选项，也有可能在一个脚本文件中构建更加复杂的命令。 为了演示，我们将使用 sed 和 distros.txt 文件来生成一个报告。我们的报告以开头标题，修改过的日期，以及 大写的发行版名称为特征。为此，我们需要编写一个脚本，所以我们将打开文本编辑器，然后输入以下文字：

# sed script to produce Linux distributions report
1 i\
\
Linux Distributions Report\
s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
我们将把 sed 脚本保存为 distros.sed 文件，然后像这样运行它：

[me@linuxbox ~]$ sed -f distros.sed distros.txt
Linux Distributions Report
SUSE    10.2    2006-12-07
FEDORA  10      2008-11-25
SUSE    11.0    2008-06-19
UBUNTU  8.04    2008-04-24
FEDORA  8       2007-11-08
SUSE    10.3    2007-10-04
UBUNTU  6.10    2006-10-26
FEDORA  7       2007-05-31
UBUNTU  7.10    2007-10-18
UBUNTU  7.04    2007-04-19
SUSE    10.1    2006-05-11
FEDORA  6       2006-10-24
FEDORA  9       2008-05-13
正如我们所见，我们的脚本文件产生了期望的结果，但是它是如何做到的呢？让我们再看一下我们的脚本文件。 我们将使用 cat 来给每行文本编号：

[me@linuxbox ~]$ cat -n distros.sed
1 # sed script to produce Linux distributions report
2
3 1 i\
4 \
5 Linux Distributions Report\
6
7 s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
8 y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
我们脚本文件的第一行是一条注释。如同 Linux 系统中的许多配置文件和编程语言一样，注释以#字符开始， 然后是人类可读的文本。注释可以被放到脚本中的任意地方（虽然不在命令本身之中），且对任何 可能需要理解和／或维护脚本的人们都很有帮助。

第二行是一个空行。正如注释一样，添加空白行是为了提高程序的可读性。

许多 sed 命令支持行地址。这些行地址被用来指定对输入文本的哪一行执行操作。行地址可能被 表示为单独的行号，行号范围，以及特殊的行号“$”，它表示输入文本的最后一行。

从第三行到第六行所包含地文本要被插入到地址 1 处，也就是输入文本的第一行中。这个 i 命令 之后是反斜杠回车符，来产生一个转义的回车符，或者就是所谓的连行符。这个序列能够 被用在许多环境下，包括 shell 脚本，从而允许把回车符嵌入到文本流中，而没有通知 解释器（在这是指 sed 解释器）已经到达了文本行的末尾。这个 i 命令，同样地，命令 a（追加文本， 而不是插入文本）和 c（取代文本）命令都允许多个文本行，只要每个文本行，除了最后一行，以一个 连行符结束。实际上，脚本的第六行是插入文本的末尾，它以一个普通的回车符结尾，而不是一个 连行符，通知解释器 i 命令结束了。

注意：一个连行符由一个斜杠字符其后紧跟一个回车符组成。它们之间不允许有空白字符。

第七行是我们的查找和替代命令。因为命令之前没有添加地址，所以输入流中的每一行文本 都得服从它的操作。

第八行执行小写字母到大写字母的字符替换操作。注意不同于 tr 命令，这个 sed 中的 y 命令不 支持字符区域（例如，[a-z]），也不支持 POSIX 字符集。再说一次，因为 y 命令之前不带地址， 所以它会操作输入流的每一行。

喜欢 sed 的人们也会喜欢。。。

sed 是一款非常强大的程序，它能够针对文本流完成相当复杂的编辑任务。它最常 用于简单的行任务，而不是长长的脚本。许多用户喜欢使用其它工具，来执行较大的工作。 在这些工具中最著名的是 awk 和 perl。它们不仅仅是工具，像这里介绍的程序，且延伸到 完整的编程语言领域。特别是 perl，经常被用来代替 shell 脚本，来完成许多系统管理任务， 同时它也是一款非常流行网络开发语言。awk 更专用一些。其具体优点是其操作表格数据的能力。 awk 程序通常逐行处理文本文件，这点类似于 sed，awk 使用了一种方案，其与 sed 中地址 之后跟随编辑命令的概念相似。虽然关于 awk 和 perl 的内容都超出了本书所讨论的范围， 但是对于 Linux 命令行用户来说，它们都是非常好的技能。

## sort
因为 sort 程序能接受命令行中的多个文件作为参数，所以有可能把多个文件合并成一个有序的文件。例如， 如果我们有三个文本文件，想要把它们合并为一个有序的文件，我们可以这样做：
```
sort file1.txt file2.txt file3.txt > final_sorted_list.txt
```

### 选项
表21-1: 常见的 sort 程序选项
| 选项 | 长选项                  | 描述                                                                                                                      |
|------|-------------------------|---------------------------------------------------------------------------------------------------------------------------|
| -b | --ignore-leading-blanks | 默认情下，对整行进行排序，从每行的第一个字符开始。这个选项导致 sort 程序忽略 每行开头的空格，从第一个非空白字符开始排序。 |
| -f | --ignore-case           | 让排序不区分大小写。                                                                                                      |
| -n | --numeric-sort          | 基于字符串的长度来排序。使用此选项允许根据数字值执行排序，而不是字母值。                                                  |
| -r | --reverse               | 按相反顺序排序。结果按照降序排列，而不是升序。                                                                            |
| -k | --key=field1[,field2]   | 对从 field1到 field2之间的字符排序，而不是整个文本行。看下面的讨论。                                                      |
| -m | --merge                 | 把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。                            |
| -o | --output=file           | 把排好序的输出结果发送到文件，而不是标准输出。                                                                            |
| -t | --field-separator=char  | 定义域分隔字符。默认情况下，域由空格或制表符分隔。                                                                        |

### 多列排序
首先，让我们看一下 -n 选项，被用做数值排序。 通过这个选项，有可能基于数值进行排序。我们通过对 du 命令的输出结果排序来说明这个选项，du 命令可以 确定最大的磁盘空间用户。通常，这个 du 命令列出的输出结果按照路径名来排序：

```
[me@linuxbox ~]$ du -s /usr/share/* | sort -nr | head
509940         /usr/share/locale-langpack
242660         /usr/share/doc
197560         /usr/share/fonts
179144         /usr/share/gnome
```
通过使用此 -nr 选项，我们产生了一个反向的数值排序，最大数值排列在第一位。这种排序起作用是 因为数值出现在每行的开头。但是如果我们想要基于文件行中的某个数值排序，又会怎样呢？ 例如，命令 ls -l 的输出结果：
```
[me@linuxbox ~]$ ls -l /usr/bin | sort -nr -k 5 | head
-rwxr-xr-x 1 root   root   8234216  2008-04-0717:42 inkscape
-rwxr-xr-x 1 root   root   8222692  2008-04-07 17:42 inkview
...
```
sort 程序的许多用法都涉及到处理表格数据，例如上面 ls 命令的输出结果。如果我们 把数据库这个术语应用到上面的表格中，我们会说每行是一条记录，并且每条记录由多个字段组成， 例如文件属性，链接数，文件名，文件大小等等。sort 程序能够处理独立的字段。在数据库术语中， 我们能够指定一个或者多个关键字段，来作为排序的关键值。在上面的例子中，我们指定 n 和 r 选项来执行相反的数值排序，并且指定 -k 5，让 sort 程序使用第五字段作为排序的关键值。

这个 k 选项非常有趣，而且还有很多特点，但是首先我们需要讲讲 sort 程序怎样来定义字段。
空白字符（空格和制表符）被当作是字段间的界定符，当执行排序时，界定符会被包含在字段当中。
```
[me@linuxbox ~]$ sort distros.txt
Fedora          10     11/25/2008
Fedora          5     03/20/2006
Fedora          6     10/24/2006
Fedora          7     05/31/2007
Fedora          8     11/08/2007
...
```
恩，大部分正确。问题出现在 Fedora 的版本号上。因为在字符集中 “1” 出现在 “5” 之前，版本号 “10” 在 最顶端，然而版本号 “9” 却掉到底端。

为了解决这个问题，我们必须依赖多个键值来排序。我们想要对第一个字段执行字母排序，然后对 第三个字段执行数值排序。sort 程序允许多个 -k 选项的实例，所以可以指定多个排序关键值。事实上， 一个关键值可能包括一个字段区域。如果没有指定区域（如同之前的例子），sort 程序会使用一个键值， 其始于指定的字段，一直扩展到行尾。下面是多键值排序的语法：
```
[me@linuxbox ~]$ sort -k=1,1 -k=2n distros.txt
Fedora         5     03/20/2006
Fedora         6     10/24/2006
Fedora         7     05/31/2007
...
```
在第一个 key 选项的实例中， 我们指定了一个字段区域。因为我们只想对第一个字段排序，我们指定了 1,1， 意味着“始于并且结束于第一个字段。”在第二个实例中，我们指定了 2n，意味着第二个字段是排序的键值， 并且按照数值排序。一个选项字母可能被包含在一个键值说明符的末尾，其用来指定排序的种类。这些 选项字母和 sort 程序的全局选项一样：b（忽略开头的空格），n（数值排序），r（逆向排序），等等。

我们列表中第三个字段包含的日期格式不利于排序。在计算机中，日期通常设置为 YYYY-MM-DD 格式， 这样使按时间顺序排序变得容易，但是我们的日期为美国格式 MM/DD/YYYY。那么我们怎样能按照 时间顺序来排列这个列表呢？

幸运地是，sort 程序提供了一种方式。这个 key 选项允许在字段中指定偏移量，所以我们能在字段中 定义键值。

```
[me@linuxbox ~]$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt
Fedora         10    11/25/2008
Ubuntu         8.10  10/30/2008
SUSE           11.0  06/19/2008
...
```
通过指定 -k 3.7，我们指示 sort 程序使用一个排序键值，其始于第三个字段中的第七个字符，对应于 年的开头。同样地，我们指定 -k 3.1和 -k 3.4来分离日期中的月和日。 我们也添加了 n 和 r 选项来实现一个逆向的数值排序。这个 b 选项用来删除日期字段中开头的空格（ 行与行之间的空格数迥异，因此会影响 sort 程序的输出结果）。

一些文件不会使用 tabs 和空格做为字段界定符；
sort 程序提供 了一个 -t 选项来定义分隔符。

```
[me@linuxbox ~]$ sort -t ':' -k 7 /etc/passwd | head
```

## uniq
当给定一个 排好序的文件（包括标准输出），uniq 会删除任意重复行，并且把结果发送到标准输出。
uniq 只会删除相邻的重复行。所以它常常和 sort 程序一块使用，来清理重复的输出。
```
[me@linuxbox ~]$ sort foo.txt | uniq
a
b
c
```
uniq 程序有几个选项。这里是一些常用选项：

表21-2: 常用的 uniq 选项
选项	说明
-c	输出所有的重复行，并且每行开头显示重复的次数。
-i	在比较文本行的时候忽略大小写。

这里我们看到 uniq 被用来报告文本文件中重复行的次数，使用这个-c 选项：
```
[me@linuxbox ~]$ sort foo.txt | uniq -c
        2 a
        2 b
        2 c
```
