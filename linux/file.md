## 文件系统的类型
我们可以通过查看 /proc/filesystems 文件来观察当前系统具体都支持哪些文件系统：
```
$ cat /proc/filesystems
```

第一列说明文件系统是否需要挂载在一个块设备上， nodev 表明后面的文件系统不需要挂接在块设备上。 第二列是内核支持的文件系统。

## mount 命令用来挂载文件系统。其基本命令格式为：
```
mount -t type [-o options] device dir

多数情况下我们不用指定 -t 参数显式地说明文件系统的类型

device：指定要挂载的设备，比如磁盘、光驱等。
dir：指定把文件系统挂载到哪个目录。
type：指定挂载的文件系统类型，一般不用指定，mount 命令能够自行判断。
options：指定挂载参数，比如 ro 表示以只读方式挂载文件系统。
```

### 通过 mount 命令查看已挂载的文件系统
如果执行 mount 命令时不加任何参数，就会输出系统挂载的所有文件系统
通过 -t 参数可以只输出指定类型的文件系统，比如-t tmpfs
```
$ mount

sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
```

让我们先来解释一下输出信息的格式和含义。输出中的每行代表挂载的一个文件系统，其格式为：
fs_spec on fs_file type fs_vfstype (fs_mntopts)
fs_spec：挂载的块设备或远程文件系统
fs_file：文件系统的挂载点
fs_vfstype：文件系统的类型
fs_mntopts：与文件系统相关的更多选项，不同的文件系统其选项也不太一样
比如上图中的第一行含义为：挂载的设备为 sysfs，挂载点为 /sys，文件系统的类型为 sysfs。括号中的 rw 表示以可读写的方式挂载文件系统，noexec 表示不能在该文件系统上直接运行程序。

### mount 命令的常见用例。
#### 格式化并挂载磁盘
对于一个磁盘分区，我们可以使用 mkfs 命令把磁盘分区格式化为指定的文件系统，比如 ext4：
```
$ sudo mkfs -t ext4 /dev/sdb1
```
然后把该分区挂载到 /mnt 目录：
```
$ sudo mount /dev/sdb1 /mnt
```

#### 以只读的方式挂载
可以把文件系统挂载为只读模式，从而保护数据。比如将 /dev/sdb1 用只读模式挂在 /mnt 目录：
```
$ sudo mount -o ro /dev/sdb1 /mnt
```
这样 /mnt 目录下的文件都是只读的。


#### 挂载虚拟文件系统
proc、tmpfs、sysfs、devpts 等都是 Linux 内核映射到用户空间的虚拟文件系统，它们不和具体的物理设备关联，但它们具有普通文件系统的特征，应用层程序可以像访问普通文件系统一样来访问他们。
比如内核的 proc 文件系统默认被挂载到了 /proc 目录，当然我们也可以再把它挂载到其它的目录，比如 /mnt 目录下：

$ sudo mount -t proc none /mnt
由于 proc 是内核虚拟的一个文件系统，并没有对应的设备，所以这里的 -t 参数不能省略。由于没有对应的源设备，这里的 none 可以是任意字符串，取个有意义的名字就可以了，因为用 mount 命令查看挂载点信息时第一列显示的就是这个字符串。

在 Linux 上我们还可以通过 tmpfs 文件系统轻松地构建出内存磁盘来。比如在内存中创建一个 512M 的 tmpfs 文件系统，并挂载到 /mnt 下，这样所有写到 /mnt 目录下的文件都存储在内存中，速度非常快，不过要注意，由于数据存储在内存中，所以断电后数据会丢失掉：

$ sudo mount -t tmpfs -o size=512m tmpfs /mnt

#### 把多个设备挂载到同一个目录
在 Linux 中可以把多个设备挂载到同一个目录。默认后面挂载的内容会让前面挂载的内容隐藏掉，只有 unmount 了后面挂载的内容，才会显示原来的内容。

#### 挂载一个设备到多个目录
我们也可以把同一个设备挂载到不同的目录，这样在不同的目录中看到的是同样的内容。还可以在不同的目录中控制挂载的权限，比如以只读方式挂载
这样从不同的目录访问相同的文件系统时就具有了不同的访问权限。

### bind mount ：在宿主机和容器间共享文件
建立隔离的文件系统之后，我们还需要一种机制从容器访问宿主机的部分文件系统，或者将容器运行过程产生的数据持久化到宿主机中。

bind mount （绑定挂载）是由 Linux 提供的一种挂载类型，它能够将一个文件或目录再次挂载到一个新的目标路径，挂载后从新旧两个路径都能访问到原来的数据，从两个路径对数据的修改也都会生效，目标路径的原有内容将会被隐藏。以如下目录结构为例：

```
$ tree .
.
├── A
│   ├── a
│   └── a.conf
└── B
    ├── b
    └── b.conf
```
通过如下命令将 A 绑定挂载到 B 目录：
```
$ mount --bind A B
```
之后从 A 和 B 目录都可以访问原 A 目录的文件内容，而 B 目录的原内容将被隐藏：
```
$ tree .
.
├── A
│   ├── a
│   └── a.conf
└── B
    ├── a
    └── a.conf
```
我们可以使用 bind mount 在宿主机和容器之间共享文件，将宿主机中的目录甚至是块设备挂载到容器中。


