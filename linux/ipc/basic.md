## socketpair
Linux实现了一个源自BSD的socketpair调用，可以实现在同一个文件描述符中进行读写的功能。
在Linux中，完全可以把这一对socket当成pipe返回的文件描述符一样使用，唯一的区别就是这一对文件描述符中的任何一个都可读和可写，函数原型如下：

```cpp
int socketpair(int domain, int type, int protocol, int sv[2]);
```

* domain表示协议族，PF_UNIX或者AF_UNIX
* type表示协议，可以是SOCK_STREAM或者SOCK_DGRAM，SOCK_STREAM基于TCP，SOCK_DGRAM基于UDP
* protocol表示类型，只能为0
* sv[2]表示套节字柄对，该两个句柄作用相同，均能进行读写双向操作
* 返回结果， 0为创建成功，-1为创建失败，并且errno来表明特定的错误号


## 共享内存
同一个系统里的两个进程通过使用共享的内存段来交换数据。共享的内存段是用户内存的一部分。每一个进程都有一个指向此内存段的指针。依靠访问权限的设置，所有进程都可以读取这一块空间中的数据。因此进程间的资源是共享的，而不是被复制来复制去的。共享内存段对于进程而言，就类似于共享变量对于线程一样。


1.共享内存段的一些基本概念
•共享内存段在内存中不依赖于进程的存在而存在。
•共享内存段有自己的名字，称为关键字（key）。
•关键字是一个整型数。
•共享内存段有自己的拥有者以及权限位。
•进程可以连接到某共享内存段，并且获得指向此段的指针。

2.使用共享内存段
（1）	如何得到共享内存段？
int seg_id = shmget（key, size - of - segment （ flags）
如果内存段存在，函数shmget找到它的位置。如果不存在，可以通过在flags值中指定 一个创建此段和初始化权限模式的请求。
（2）	如何将进程连接到某个共享内存段？
void ptr = * shmat（ seg_id, NULL, flags）
shmat在进程的地址空间中创建共享内存段的部分,并返回一个指向此段的指针°nags 参数用来指定此内存段是否为只读。
（3）	如何与共享内存段进行读写交互？
strcpy（ptr, "hello"）；
memcpy（）、ptr[i]及其他一些通用的指针操作。

5,共享内存段类型的IPC小结
访问：客户端必须有对共享内存段的读权限。共享内存段拥有一个权限系统，它的工作原理和文件权限系统类似。共享内存段有自己的拥有者并且为用户、组或其他成员设置了权限位，来控制他们各自的访问权限。正因为有如此特性，才可以让服务器只有写权限而客户端只有读权限。
多个客户：任意数目的客户都可以同时从共享内存段读数据。
竞态条件：服务器通过调用一个运行在用户空间的库函数strcpy来更新共享的内存段。 如果客户端正好在服务器向内存段中写入新数据的时候来访问内存段，那么它可能既读到新数据也读到老数据。
避免竞态条件：服务器和客户段必须使用相同的系统来对资源加锁。内核提供了一种进程间加锁的机制，称为信号量机制。
