## 通过文件的进程间通信
进程间可以通过文件来进行通信。某进程将数据写入文件，别的进程再将数据从文件中读出。

### 使用文件的IPC小结
- 访问控制：客户端必须能够读取文件。通过使用标准文件访问权限，可以给予服务器写权限并且限制客户端只有读权限。
- 多客户端：任意数目的客户可以同时从文件中读取数据。Unix并不限制同时打开同一文件的进程数目。
- 竞态条件：服务器通过清空内容再重写的方法来更新文件。如果某客户恰好在清空和重写之间读取文件，那么它得到的将是一个空的或只有部分的内容。
- 避免竞态条件：服务器和客户端可以使用某种类型的互斥量来避免竞态条件。后面的章节中大家将会学到文件锁的方法。另外，如果服务器在程序中使用lseek和write函数来替换create,这样文件永远都不可能为空，因为write是一个原子操作，它不会在执行中被打断。

## 文件锁
### 1.两种类型的锁
考虑两种类型的问题。首先，当客户试图读取文件时，服务器正在重写文件，结果会如何呢？客户读出来的可能就是不完整的数据。
再考虑一下正好相反的情况。当客户正在一行一行读数据的时候，服务器突然把文件抢过来，将内容删除，然后开始重写数据。客户端看着文件从自己眼皮底下被抢过去而无能 
为力。因此，当客户在读取文件的时候，服务器也必须等待客户完成。其他的客户不必去等，因为多个进程一起读文件不会带来任何风险。
为了避免这些问题,需要两种类型的锁。第一种类型为写数据锁，它告诉其他进程：“我在写文件，在完成之前任何人都必须等待。”第二种类型的锁为读数据锁，它告诉其他进程: “我在读文件，要写文件必须等我完成，要读文件的不受影响。”

### 2.使用文件锁进行编程
Unix提供了3种方法锁住打开的文件：flock、lockf和fcntl。三者中最灵活和移植性最好的应该是fcntl。
下面使用fcntl锁文件。

(1)如何给已经打开的文件加读数据锁？
```cpp
fcntl(fd,F_SETLKW,&lockinfo)

struct flock {
   ...
   short l_type;    /* Type of lock: F_RDLCK,
					   F_WRLCK, F_UNLCK */
   short l_whence;  /* How to interpret l_start:
					   SEEK_SET, SEEK_CUR, SEEK_END */
   off_t l_start;   /* Starting offset for lock */
   off_t l_len;     /* Number of bytes to lock */
   pid_t l_pid;     /* PID of process blocking our lock
					   (set by F_GETLK and F_OFD_GETLK) */
   ...
};
```
第一个参数是该文件对应的文件描述符。第二个参数F_SETLKW说明若必要的话，可 以等待其他的进程释放锁。第三个参数指向一个struct flock类型的变量。

(2)如何在打开的文件上加写数据锁？
使用 fcntl(fd,F_SETLKW,&lockinfo)，并将 lockinfo. l_type 置 F_WRLCK0
(3)怎样解锁？
使用 fcntl(fd,F_SETLKW,&lockinfo)，并将 lockinfo. l_type 置 F_UNLCKO
(4)如何只锁住文件的一部分？
使用 fcntKfd,F SETLKW, &lockinfo),并将 lockinfo. l_start 置为开始位置的偏移量, 同时将lockinfo. l_len置为区域的长度。

5,文件锁：小结
使用F_SETLKW 参数调用fcntl可以使进程挂起直到内核允许进程设置指定的锁。在读取数据之前，客户必须设置读取数据的锁。若服务器对文件加写数据锁，客户只好等待服务器完成。服务器在重写数据之前，也必须对文件加写数据锁，如果这时客户加了一个读数据的锁，那服务器会被挂起直到所有客户释放这个锁。

6,重要细节：进程可以忽略锁机制
在前面对于文件锁的讨论中，不管客户还是服务器在读或修改文件的时候，程序都是自觉有序地等待，设置及释放文件锁。那么当别的进程设置了锁的时候,其他进程是否可以忽略它，仍旧继续原来的读取或是修改操作吗?答案是肯定的。Unix的锁机制允许进程通过这种方式合作，但并不强迫它们一定要用。
