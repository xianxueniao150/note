## socketpair
Linux实现了一个源自BSD的socketpair调用，可以实现在同一个文件描述符中进行读写的功能。
在Linux中，完全可以把这一对socket当成pipe返回的文件描述符一样使用，唯一的区别就是这一对文件描述符中的任何一个都可读和可写，函数原型如下：

```cpp
int socketpair(int domain, int type, int protocol, int sv[2]);
```

* domain表示协议族，PF_UNIX或者AF_UNIX
* type表示协议，可以是SOCK_STREAM或者SOCK_DGRAM，SOCK_STREAM基于TCP，SOCK_DGRAM基于UDP
* protocol表示类型，只能为0
* sv[2]表示套节字柄对，该两个句柄作用相同，均能进行读写双向操作
* 返回结果， 0为创建成功，-1为创建失败，并且errno来表明特定的错误号

## 命名管道
通常的管道只能连接相关的进程。常规管道由进程创建，并由最后一个进程关闭。
使用命名管道可以连接不相关的进程，并且可以独立于进程存在。称这样的命名管道为FIFO（先进先出队列）。

1.使用FIFO
(1)如何创建FIFO?
库函数mkfifo(char * name, mode_t mode)使用指定的权限模式来创建FIFO。mkfifo 命令通常调用这个函数。
(2)如何删除FIFO?
类似于删除文件,unlink(fifoname)函数可以用来删除FIFO。
(3)如何监听FIFO的连接？
使用open(fifoname,O_RDONLY)函数。open函数阻塞进程直到某一进程打开FIFO 进行写操作。
(4)如何通过FIFO开始会话？
使用open(fifoname,0_WRONLY)函数。此时open函数阻塞进程直到某一进程打开 FIFO进行读取操作。
(5)两进程如何通过FIFO进行通信？
发送进程用write调用，而监听进程使用read调用。写进程调用close来通知读进程通 信结束。

2.FIFO类型的IPC小结
访问：FIFO使用与通常文件相同的文件访问。服务器有写权限，而客户端只限于读权限。
多个客户端：命名管道是一个队列而不是常规文件。写者将字节写入队列，而读者从队列头部移出字节。每个客户端都会将时间/日期的数据移出队列，因此服务器必须重写数据。
竞态条件：FIFO版本的时间/日期服务器程序完全不存在竞态条件问题。在信息的长度不超过管道的容量的情况下,read和write系统调用只是原子操作。读取操作将管道清空而写入操作又将管道塞满。在读者和写者连通之前，系统内核将进程挂起。因此锁机制在这里并不需要。
时间/日期服务器将数据写入FIFO后，将自己挂起直到客户端打开FIFO来读取数据。 

## 共享内存
同一个系统里的两个进程通过使用共享的内存段来交换数据。共享的内存段是用户内存的一部分。每一个进程都有一个指向此内存段的指针。依靠访问权限的设置，所有进程都可以读取这一块空间中的数据。因此进程间的资源是共享的，而不是被复制来复制去的。共享内存段对于进程而言，就类似于共享变量对于线程一样。


1.共享内存段的一些基本概念
•共享内存段在内存中不依赖于进程的存在而存在。
•共享内存段有自己的名字，称为关键字（key）。
•关键字是一个整型数。
•共享内存段有自己的拥有者以及权限位。
•进程可以连接到某共享内存段，并且获得指向此段的指针。

2.使用共享内存段
（1）	如何得到共享内存段？
int seg_id = shmget（key, size - of - segment （ flags）
如果内存段存在，函数shmget找到它的位置。如果不存在，可以通过在flags值中指定 一个创建此段和初始化权限模式的请求。
（2）	如何将进程连接到某个共享内存段？
void ptr = * shmat（ seg_id, NULL, flags）
shmat在进程的地址空间中创建共享内存段的部分,并返回一个指向此段的指针°nags 参数用来指定此内存段是否为只读。
（3）	如何与共享内存段进行读写交互？
strcpy（ptr, "hello"）；
memcpy（）、ptr[i]及其他一些通用的指针操作。

5,共享内存段类型的IPC小结
访问：客户端必须有对共享内存段的读权限。共享内存段拥有一个权限系统，它的工作原理和文件权限系统类似。共享内存段有自己的拥有者并且为用户、组或其他成员设置了权限位，来控制他们各自的访问权限。正因为有如此特性，才可以让服务器只有写权限而客户端只有读权限。
多个客户：任意数目的客户都可以同时从共享内存段读数据。
竞态条件：服务器通过调用一个运行在用户空间的库函数strcpy来更新共享的内存段。 如果客户端正好在服务器向内存段中写入新数据的时候来访问内存段，那么它可能既读到新数据也读到老数据。
避免竞态条件：服务器和客户段必须使用相同的系统来对资源加锁。内核提供了一种进程间加锁的机制，称为信号量机制。
