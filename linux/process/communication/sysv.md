System V IPC 包括三种不同的进程间通信机制。
y 消息队列用来在进程之间传递消息。消息队列与管道有点像，但存在两个重大差别。
第一是消息队列是存在边界的，这样读者和写者之间以消息进行通信，而不是通过无
分隔符的字节流进行通信的。第二是每条消息包括一个整型的 type 字段，并且可以通
过类型类选择消息而无需以消息被写入的顺序来读取消息。
y 信号量允许多个进程同步它们的动作。一个信号量是一个由内核维护的整数值，它对
所有具备相应权限的进程可见。一个进程通过对信号量的值进行相应的修改来通知其
他进程它正在执行某个动作。
y 共享内存使得多个进程能够共享内存（即同被映射到多个进程的虚拟内存的页帧）的
同一块区域（称为一个段）。由于访问用户空间内存的操作是非常快的，因此共享内
存是其中一种速度最快的 IPC 方法：一个进程一旦更新了共享内存，那么这个变更会
立即对共享同一个内存段的其他进程可见。

System V IPC 是一个通过 CONFIG_SYSVIPC 选项进行配置的内核选项。

图第 45 章 System V IPC 介绍 757
45.1 概述
表 45-1 对使用 System V IPC 对象需用到的头文件和系统调用进行了总结。
一些实现要求在包含表 45-1 中的头文件之前先包含<sys/types.h>。一些较早的 UNIX 实现
可能还要求包含<sys/ipc.h>。（没有哪个 UNIX 规范要求这些头文件。）
表 45-1：System V IPC 对象编程接口总结
接 口 消 息 队 列 信 号 量 共 享 内 存
头文件 <sys/msg.h> <sys/sem.h> <sys/shm.h>
关联数据结构 msqid_ds semid_ds shmid_ds
创建/打开对象 msgget() semget() shmget() + shmat()
关闭对象 （无） （无） shmdt()
控制操作 msgctl() semctl() shmctl()
执行 IPC msgsnd()——写入消息 semop()——测试/调整信号量 访问共享区域中的内存
msgrcv()——接收消息
在大多数部署 Linux 的硬件架构上，系统调用 ipc(2)是所有 System V IPC 操作到内核的
入口，表 45-1 中列出的所有调用实际上都被实现为位于这个系统调用之上的库函数。（这
个约定的两个例外情况是 Alpha 和 IA-64，在这两个架构上，表中列出的调用被实现成了各
个系统调用。）这个不太常见的方法是 System V IPC 在一开始被实现成可载入的内核模块的
杰作。尽管在大多数 Linux 架构上它们实际上是库函数，但在本章中会将表 45-1 中列出的
函数称为系统调用。只有 C 库的实现人员才需要使用 ipc(2)ipc(2)，在任何其他应用程序中
使用这个调用将会使应用程序变得不可移植。

### 创建和打开一个 System V IPC 对象
```cpp
int msgget(key_t key, int msgflg);
```
每种 System V IPC 机制都有一个相关的 get 系统调用（msgget()、semget()或 shmget()）， 它与文件上的 open()系统调用类似。给定一个整数 key（类似于文件名），get 调用完成下列某个操作。
-  使用给定的 key 创建一个新 IPC 对象并返回一个唯一的标识符来标识该对象。
-  返回一个拥有给定的 key 的既有 IPC 对象的标识符。(打开一个既有 IPC 对象)

get 调用所做的事情是将一个数字（key）转换称为另一个数字（标识符）。

IPC 标识符与文件描述符类似，在后续所有引用该 IPC 对象的系统调用中都需要用到它。 但这两者之间存在一个重要的语义上的差别。文件描述符是一个进程特性，而 IPC 标识符则是对象本身的一个属性并且对系统全局可见。所有访问同一对象的进程使用同样的标识符。 这意味着如果知道一个 IPC 对象已经存在，那么可以跳过 get 调用，只要能够通过某种机制来获知对象的标识符即可。例如，创建对象的进程可能会将标识符写入一个可供其他进程读取的文件。

key 是第一个参数，标识符是函数的返回结果。传递给 get 调用 的最后一个参数（flags）使用与文件一样的掩码常量指定了新对象上的权限。
进程的 umask 对新创建的 IPC 对象上的权限是不适用的。

所有需访问同一个 IPC 对象的进程在执行 get 调用时会指定同样的 key 以获取该对象的同 一个标识符。
如果没有与给定的 key 对应的 IPC 对象存在并且在 flags 参数中指定了 IPC_CREAT（与 open()的 O_CREAT 标记类似），那么 get 调用会创建一个新的 IPC 对象。如果不存在相应的 IPC 对象并且没有指定 IPC_CREAT（并且没有将 key 指定为 IPC_PRIVATE）， 那么 get 调用会失败并返回 ENOENT 错误。
一个进程可以通过指定 IPC_EXCL 标记（类似于 open()的 O_EXCL 标记）来确保它是创建 IPC 对象的进程。如果指定了 IPC_EXCL 并且与给定 key 对应的 IPC 对象已经存在，那么 get 调用会失败并返 EEXIST 错误。 

### IPC 对象删除和对象持久
各种 System V IPC 机制的 ctl 系统调用（msgctl()、semctl()、shmctl()）在对象上执行一组 控制操作，其中很多操作是特定于某种 IPC 机制的，但有一些是适用于所有的 IPC 机制的， 其中一个就是 IPC_RMID 控制操作，它可以用来删除一个对象。如使用下面的调用可以删除 一个共享内存对象。 
```cpp
shmctl(id,IPC_RMID,NULL)
```
对于消息队列和信号量来讲，IPC 对象的删除是立即生效的，对象中包含的所有信息 都会被销毁，不管是否有其他进程仍然在使用该对象。（这也是 System IPC 对象的操作与文件的操作不相似的其中一个地方）
共享内存对象的删除的操作是不同的。在 shmctl(id,IPC_RMID, NULL)调用之后，只有当所有使用该内存段的进程与该内存段分离之后（使用 shmdt()）才会删除该共享内存段。（这一点与文件删除更加接近。）

System V IPC 对象具备内核持久性。一旦被创建之后，一个对象就一直存在直到它被显式地删除或系统被关闭。System V IPC 对象的这个属性是非常有用的。因为一个进程可以创建一个对象、修改其状态、然后退出并使得在后面某个时刻启动的进程可以访问这个对象。 但这种属性也是存在缺点的，其原因如下。
-  系统对每种类型的 IPC 对象的数量是有限制的。如果没有删除不用的对象，那么应用程序最终可能会因达到这个限制而发生错误。
-  在删除一个消息队列或信号量对象时，多进程应用程序可能难以确定哪个进程是最后一个需要访问对象的进程，从而导致难以确定何时可以安全地删除对象。这里的问题是这些对象是无连接的——内核不会记录哪个进程打开了对象。（共享内存段不存在这个缺点，因为它们的删除操作的语义不同。）

## IPC Key
System V IPC key 是一个整数值，其数据类型为 key_t。IPC get 调用将一个 key 转换成相应的整数 IPC 标识符。这些调用能够确保如果创建的是一个新 IPC 对象，那么对象能够得到一个唯一的标识符，如果指定了一个既有对象的 key，那么总是会取得该对象的（同样的）标识符。
那么如何产生唯一的 key 呢——一种确保不会偶然地取得其他应用程序所使用的一个既有 IPC 对象的标识符？这个问题存在三种解决方案。
-  随机地选取一个整数值作为 key 值，这些整数值通常会被放在一个头文件中，所有使用 IPC 对象的程序都需要包含这个头文件。这个方法的难点在于可能会无意中选取了一个已被另一个应用程序使用的值。
-  在创建 IPC 对象的 get 调用中将 IPC_PRIVATE 常量作为 key 的值，这样就会导致每个调用都会创建一个全新的 IPC 对象，从而确保每个对象都拥有一个唯一的 key。
-  使用 ftok()函数生成一个（接近唯一）key。

IPC_PRIVATE 和 ftok()是通常采用的技术。

### 使用 IPC_PRIVATE 产生一个唯一的 key
在创建一个新 IPC 对象时必须要像下面这样将 key 指定为 IPC_PRIVATE。
```cpp
//无需指定 IPC_CREAT 和 IPC_EXCL 标记。
id=msgget(IPC_PRIVATE,0666)
```
这项技术对于父进程在执行 fork()之前创建 IPC 对象从而导致子进程继承 IPC 对象标识符的多进程应用程序是特别有用的。在客户端-服务器应用程序中（即那些包含非相关进程的应用程序）也可以使用这项技术，但客户端必须要通过某种机制获取由服务器创建的 IPC 对象的标识符（反之亦然）。如在创建完一个 IPC 对象之后，服务器可以将这个标识符写入一个将会被客户端读取的文件中。

if (shmctl(id, IPC_RMID, NULL) == -1)    errExit("shmctl"); 
id = msgget(key, IPC_CREAT | S_IRUSR | S_IWUSR);
if (id == -1)
    errExit("msgget");


uid 和 gid 字段指定了 IPC 对象的所有权。cuid 和 cgid 字段保存着创建该对象的进程的用户 ID 和组 ID。一开始，所有者和创建者 ID 字段的值是一样的，它们都源自调用进程的有效 ID。创建者 ID 是不可变的，而所有者 ID 则可以通过 IPC_SET 操作进行修改。下面的代码演示了如何修改共享内存段的 uid 字段（关联数据结构的类型是 shmid_ds）
```cpp
struct shmid_ds shmds;
if (shmctl(id, IPC_STAT, &shmds) == -1)     /* Fetch from kernel */
    errExit("shmctl");
    errExit("shmctl");
```
